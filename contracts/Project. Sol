// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title SupplyChainVerification
 * @dev A transparent and secure supply chain tracking system
 * @author Supply Chain Team
 */
contract Project {
    
    // Enum for product status at different stages
    enum Status {
        Manufactured,
        InTransit,
        AtDistributor,
        Shipped,
        AtRetailer,
        Delivered
    }
    
    // Structure to represent a product
    struct Product {
        uint productId;
        string productName;
        string manufacturer;
        Status currentStatus;
        address currentOwner;
        uint registrationTime;
        bool exists;
    }
    
    // Structure to track status history
    struct StatusUpdate {
        Status status;
        uint timestamp;
        string location;
        address updatedBy;
    }
    
    // State variables
    address public admin;
    uint public totalProducts;
    
    // Mappings
    mapping(uint => Product) public products;
    mapping(uint => StatusUpdate[]) public productHistory;
    mapping(address => bool) public authorizedParticipants;
    
    // Events
    event ProductRegistered(
        uint indexed productId, 
        string productName, 
        address indexed manufacturer,
        uint timestamp
    );
    
    event StatusUpdated(
        uint indexed productId, 
        Status newStatus, 
        string location, 
        uint timestamp,
        address indexed updatedBy
    );
    
    event OwnershipTransferred(
        uint indexed productId, 
        address indexed from, 
        address indexed to,
        uint timestamp
    );
    
    event ParticipantAuthorized(address indexed participant);
    event ParticipantRevoked(address indexed participant);
    
    // Modifiers
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can perform this action");
        _;
    }
    
    modifier onlyAuthorized() {
        require(
            authorizedParticipants[msg.sender] || msg.sender == admin, 
            "Not authorized"
        );
        _;
    }
    
    modifier productExists(uint _productId) {
        require(products[_productId].exists, "Product does not exist");
        _;
    }
    
    modifier onlyProductOwner(uint _productId) {
        require(
            products[_productId].currentOwner == msg.sender,
            "You are not the current owner"
        );
        _;
    }
    
    /**
     * @dev Constructor sets the contract deployer as admin
     */
    constructor() {
        admin = msg.sender;
        authorizedParticipants[admin] = true;
        totalProducts = 0;
    }
    
    /**
     * @dev Register a new product in the supply chain
     * @param _productId Unique identifier for the product
     * @param _productName Name of the product
     * @param _manufacturer Name of the manufacturer
     * @notice Only authorized participants can register products
     */
    function registerProduct(
        uint _productId,
        string memory _productName,
        string memory _manufacturer
    ) public onlyAuthorized {
        require(_productId > 0, "Invalid product ID");
        require(!products[_productId].exists, "Product already registered");
        require(bytes(_productName).length > 0, "Product name cannot be empty");
        require(bytes(_manufacturer).length > 0, "Manufacturer cannot be empty");
        
        products[_productId] = Product({
            productId: _productId,
            productName: _productName,
            manufacturer: _manufacturer,
            currentStatus: Status.Manufactured,
            currentOwner: msg.sender,
            registrationTime: block.timestamp,
            exists: true
        });
        
        // Add initial status to history
        productHistory[_productId].push(StatusUpdate({
            status: Status.Manufactured,
            timestamp: block.timestamp,
            location: "Manufacturing Facility",
            updatedBy: msg.sender
        }));
        
        totalProducts++;
        
        emit ProductRegistered(_productId, _productName, msg.sender, block.timestamp);
    }
    
    /**
     * @dev Update the status of a product in the supply chain
     * @param _productId ID of the product to update
     * @param _newStatus New status of the product
     * @param _location Current location of the product
     * @notice Only authorized participants can update status
     */
    function updateStatus(
        uint _productId,
        Status _newStatus,
        string memory _location
    ) public onlyAuthorized productExists(_productId) {
        require(bytes(_location).length > 0, "Location cannot be empty");
        require(
            uint(_newStatus) > uint(products[_productId].currentStatus),
            "Invalid status progression"
        );
        
        products[_productId].currentStatus = _newStatus;
        
        // Add to history
        productHistory[_productId].push(StatusUpdate({
            status: _newStatus,
            timestamp: block.timestamp,
            location: _location,
            updatedBy: msg.sender
        }));
        
        emit StatusUpdated(_productId, _newStatus, _location, block.timestamp, msg.sender);
    }
    
    /**
     * @dev Transfer ownership of a product to another party
     * @param _productId ID of the product
     * @param _newOwner Address of the new owner
     * @notice Only current owner can transfer ownership
     */
    function transferOwnership(
        uint _productId,
        address _newOwner
    ) public productExists(_productId) onlyProductOwner(_productId) {
        require(_newOwner != address(0), "Invalid new owner address");
        require(_newOwner != msg.sender, "Cannot transfer to yourself");
        require(
            authorizedParticipants[_newOwner] || _newOwner == admin,
            "New owner must be authorized"
        );
        
        address previousOwner = products[_productId].currentOwner;
        products[_productId].currentOwner = _newOwner;
        
        emit OwnershipTransferred(_productId, previousOwner, _newOwner, block.timestamp);
    }
    
    /**
     * @dev Authorize a participant to interact with the supply chain
     * @param _participant Address to authorize
     * @notice Only admin can authorize participants
     */
    function authorizeParticipant(address _participant) public onlyAdmin {
        require(_participant != address(0), "Invalid address");
        require(!authorizedParticipants[_participant], "Already authorized");
        
        authorizedParticipants[_participant] = true;
        emit ParticipantAuthorized(_participant);
    }
    
    /**
     * @dev Revoke authorization from a participant
     * @param _participant Address to revoke
     * @notice Only admin can revoke authorization
     */
    function revokeParticipant(address _participant) public onlyAdmin {
        require(_participant != address(0), "Invalid address");
        require(_participant != admin, "Cannot revoke admin");
        require(authorizedParticipants[_participant], "Not authorized");
        
        authorizedParticipants[_participant] = false;
        emit ParticipantRevoked(_participant);
    }
    
    /**
     * @dev Get complete product information
     * @param _productId ID of the product
     * @return Product structure with all details
     */
    function getProduct(uint _productId) 
        public 
        view 
        productExists(_productId) 
        returns (Product memory) 
    {
        return products[_productId];
    }
    
    /**
     * @dev Get current status of a product
     * @param _productId ID of the product
     * @return Current status enum value
     */
    function getProductStatus(uint _productId) 
        public 
        view 
        productExists(_productId) 
        returns (Status) 
    {
        return products[_productId].currentStatus;
    }
    
    /**
     * @dev Get current owner of a product
     * @param _productId ID of the product
     * @return Address of current owner
     */
    function getCurrentOwner(uint _productId) 
        public 
        view 
        productExists(_productId) 
        returns (address) 
    {
        return products[_productId].currentOwner;
    }
    
    /**
     * @dev Get complete history of a product
     * @param _productId ID of the product
     * @return Array of StatusUpdate structures
     */
    function getProductHistory(uint _productId) 
        public 
        view 
        productExists(_productId) 
        returns (StatusUpdate[] memory) 
    {
        return productHistory[_productId];
    }
    
    /**
     * @dev Verify if a product exists and get basic info
     * @param _productId ID of the product
     * @return exists Whether product exists
     * @return productName Name of the product
     * @return currentStatus Current status of the product
     */
    function verifyProduct(uint _productId) 
        public 
        view 
        returns (bool exists, string memory productName, Status currentStatus) 
    {
        Product memory product = products[_productId];
        return (product.exists, product.productName, product.currentStatus);
    }
    
    /**
     * @dev Check if an address is authorized
     * @param _participant Address to check
     * @return True if authorized, false otherwise
     */
    function isAuthorized(address _participant) public view returns (bool) {
        return authorizedParticipants[_participant];
    }
    
    /**
     * @dev Get total number of registered products
     * @return Total product count
     */
    function getTotalProducts() public view returns (uint) {
        return totalProducts;
    }
    
    /**
     * @dev Get status history count for a product
     * @param _productId ID of the product
     * @return Number of status updates
     */
    function getHistoryCount(uint _productId) 
        public 
        view 
        productExists(_productId) 
        returns (uint) 
    {
        return productHistory[_productId].length;
    }
}
